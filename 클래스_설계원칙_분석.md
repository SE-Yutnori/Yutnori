# 윷놀이 게임 클래스 설계원칙 분석

## 주요 클래스 목록

### Model 계층
1. **Player** - 플레이어 정보 관리
2. **Token** - 말(토큰) 상태 관리 
3. **Board** - 게임 보드 구조
4. **BoardNode** - 보드의 각 노드
5. **GameState** - 전체 게임 상태 관리
6. **YutGameRules** - 윷 던지기 및 게임 로직
7. **TokenPositionManager** - 토큰 위치 관리

### View 계층
8. **GameLauncher** - 게임 시작 및 초기화
9. **InGameView** - 게임 화면 뷰
10. **BoardView** - 보드 그래픽 뷰

### Controller 계층
11. **GameController** - 게임 제어 로직

---

## GRASP 원칙 분석

### 1. **Information Expert (정보 전문가)**

#### Player 클래스
```java
public class Player {
    private String name;
    private List<Token> tokens;
    
    public boolean hasFinished() {
        // 자신의 토큰 정보를 가지고 있으므로 승리 판단 담당
        return tokens.stream().allMatch(token -> token.getState() == TokenState.FINISHED);
    }
}
```
- **적용**: Player가 자신의 토큰 정보를 가지고 있으므로 승리 조건 판단 담당
- **이유**: 토큰 리스트와 상태 정보를 가장 잘 알고 있는 클래스

#### TokenPositionManager 클래스
```java
public class TokenPositionManager {
    private final Map<Token, BoardNode> tokenPositions;
    
    public BoardNode getTokenPosition(Token token) {
        return tokenPositions.get(token); // 위치 정보를 가지고 있으므로 위치 조회 담당
    }
}
```
- **적용**: 토큰-위치 매핑 정보를 가지고 있으므로 위치 관련 모든 작업 담당
- **이유**: 토큰 위치 데이터의 전문가

### 2. **Creator (생성자)**

#### Player 클래스
```java
public Player(String name, int tokenCount) {
    this.tokens = new ArrayList<>();
    for (int i = 1; i <= tokenCount; i++) {
        Token token = new Token(name + "-" + i, this); // Player가 Token 생성
        tokens.add(token);
    }
}
```
- **적용**: Player가 Token을 생성
- **이유**: Player가 Token을 소유하고 사용하며, Token 초기화 정보를 가지고 있음

#### GameState 클래스
```java
public GameState(int sides, float radius, List<String> playerNames, List<Integer> tokenCounts) {
    this.board = new Board(sides, radius); // Board 생성
    this.tokenPositionManager = new TokenPositionManager(board); // Manager 생성
    // Player 생성...
}
```
- **적용**: GameState가 Board, TokenPositionManager, Player들을 생성
- **이유**: 게임 전체를 집합하고 초기화 정보를 가지고 있음

### 3. **Controller (제어자)**

#### GameController 클래스
```java
public class GameController {
    public void rollingYut() {
        // 1. 윷 던지기
        YutGameRules.YutThrowResult result = gameState.throwYut();
        // 2. 결과 처리
        // 3. 이동 로직 제어
        // 4. 승리 조건 확인
    }
}
```
- **적용**: 게임의 전반적인 흐름을 제어
- **이유**: Model과 View 사이의 중재자 역할

### 4. **Low Coupling (낮은 결합도)**

#### Token 클래스
```java
public class Token {
    private final Player owner; // Player 참조만 유지
    void setState(TokenState state) { // 상태 변경은 package-private
        this.state = state;
    }
}
```
- **적용**: Token은 Owner 정보만 알고, 직접적인 게임 로직에는 관여하지 않음
- **이유**: 단순한 데이터 객체로 설계하여 다른 클래스와의 의존성 최소화

### 5. **High Cohesion (높은 응집도)**

#### YutGameRules 클래스
```java
public class YutGameRules {
    public static int throwOneYut() { ... }          // 윷 던지기
    public static MoveResult moveToken() { ... }     // 토큰 이동
    public static MoveResult moveTokenBackward() { ... } // 빽도 이동
}
```
- **적용**: 윷놀이 게임 규칙과 관련된 모든 로직을 한 곳에 집중
- **이유**: 관련된 기능들이 응집되어 유지보수성 향상

---

## SOLID 원칙 분석

### 1. **SRP (Single Responsibility Principle) - 단일 책임 원칙**

#### Player 클래스
- **책임**: 플레이어 정보와 소유 토큰 관리
- **변경 이유**: 플레이어 관련 요구사항 변경 시에만
```java
public class Player {
    // 오직 플레이어와 관련된 기능만 담당
    public boolean hasFinished() { ... }
    public List<Token> getMovableTokens() { ... }
    public List<Token> getReadyTokens() { ... }
}
```

#### TokenPositionManager 클래스
- **책임**: 토큰 위치 관리
- **변경 이유**: 위치 관리 방식 변경 시에만
```java
public class TokenPositionManager {
    // 오직 토큰 위치 관리만 담당
    public void placeTokenAtStart(Token token) { ... }
    public BoardNode getTokenPosition(Token token) { ... }
    public void updateTokenPosition(Token token, BoardNode newPosition) { ... }
}
```

#### YutGameRules 클래스
- **책임**: 윷놀이 게임 규칙
- **변경 이유**: 게임 규칙 변경 시에만
```java
public class YutGameRules {
    // 오직 게임 규칙만 담당
    public static YutThrowResult throwYut() { ... }
    public static MoveResult moveToken() { ... }
}
```

### 2. **OCP (Open-Closed Principle) - 개방-폐쇄 원칙**

#### Board 클래스
```java
public Board(int sides, float radius) {
    // 다양한 각형(4,5,6각형) 지원을 위해 확장 가능
    // 새로운 보드 타입 추가 시 기존 코드 수정 없이 확장 가능
}
```
- **개방**: 새로운 보드 형태(7각형, 8각형 등) 추가 가능
- **폐쇄**: 기존 4,5,6각형 보드 코드는 수정하지 않음

#### TokenState 열거형
```java
enum TokenState {
    READY, ACTIVE, FINISHED
    // 새로운 상태 추가 시 확장 가능 (예: SUSPENDED, CAPTURED)
}
```

### 3. **LSP (Liskov Substitution Principle) - 리스코프 치환 원칙**

#### Token 상속 구조 (잠재적 확장성)
```java
// 현재는 단일 Token 클래스이지만, 향후 확장 시
// SpecialToken extends Token 같은 구조에서도 LSP 준수 가능
public class Token {
    public TokenState getState() { return state; }
    // 서브클래스에서 오버라이드해도 동일한 계약 유지
}
```

### 4. **ISP (Interface Segregation Principle) - 인터페이스 분리 원칙**

#### 분리된 책임
```java
// 각 클래스가 필요한 메서드만 노출
public class Player {
    // 플레이어 관련 메서드만
    public List<Token> getTokens() { ... }
    public boolean hasFinished() { ... }
}

public class TokenPositionManager {
    // 위치 관리 관련 메서드만  
    public BoardNode getTokenPosition(Token token) { ... }
    public void updateTokenPosition(Token token, BoardNode newPosition) { ... }
}
```
- **적용**: 각 클래스가 자신의 역할에 필요한 메서드만 제공
- **장점**: 클라이언트가 불필요한 의존성을 갖지 않음

### 5. **DIP (Dependency Inversion Principle) - 의존성 역전 원칙**

#### GameController와 GameState
```java
public class GameController {
    private final GameState gameState; // 구체 클래스에 의존
    private final InGameView view;     // 구체 클래스에 의존
    
    // 향후 인터페이스 도입 시:
    // private final IGameState gameState;
    // private final IGameView view;
}
```
- **현재**: 구체 클래스에 의존 (개선 여지 있음)
- **개선 방향**: 인터페이스 도입으로 DIP 적용 가능

#### YutGameRules의 정적 메서드
```java
public class YutGameRules {
    // 정적 메서드로 구현하여 의존성 없음
    public static MoveResult moveToken(Token token, int steps, ...) {
        // 파라미터로 받은 객체들에만 의존
    }
}
```

---

## 설계 품질 평가

### **잘 적용된 원칙들**

1. **Information Expert**: 각 클래스가 자신의 데이터에 대한 책임을 명확히 가짐
2. **High Cohesion**: YutGameRules, TokenPositionManager 등이 관련 기능을 잘 응집
3. **SRP**: 각 클래스가 명확한 단일 책임을 가짐
4. **Creator**: 적절한 생성자-피생성자 관계 설정

### **개선 가능한 부분**

1. **DIP**: 인터페이스 도입으로 의존성 역전 적용 가능
2. **OCP**: 더 많은 확장 포인트 제공 가능
3. **Low Coupling**: 일부 클래스 간 결합도 추가 완화 가능

### **설계의 장점**

- **유지보수성**: 책임이 명확히 분리되어 수정 시 영향 범위가 제한적
- **확장성**: 새로운 보드 타입, 토큰 상태 등 쉽게 추가 가능
- **테스트 용이성**: 각 클래스의 책임이 명확해 단위 테스트 작성 용이
- **가독성**: 클래스명과 메서드명이 역할을 명확히 표현

### **전체 평가**: 8.5/10
대부분의 GRASP와 SOLID 원칙을 잘 적용한 설계로, 향후 확장과 유지보수에 유리한 구조를 갖추고 있습니다. 